# Backend Files Compilation for SSE Streaming Implementation
# Generated on: 2025-09-10 11:26:22
# Working directory: /Users/dj/saop_cli/saop/templates/base_agent

# ============================================================================
# FILE: api/routes.py
# ============================================================================

# api/routes.py
"""
Authentication routes for SAOP agent platform.
Provides OAuth2 token endpoints and user management.
"""
from datetime import timedelta
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from pydantic import BaseModel
from typing import List

from api.auth import (
    auth_provider,
    require_authentication,
    require_role,
    require_permission,
    Token,
    User,
    Role,
    Permission
)

router = APIRouter()

# Response models
class UserResponse(BaseModel):
    username: str
    email: str
    full_name: str
    roles: List[Role]
    permissions: List[Permission]
    disabled: bool

class HealthResponse(BaseModel):
    status: str
    authentication: str
    timestamp: str

# OAuth2 token endpoint
@router.post("/token", response_model=Token)
async def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):
    """
    OAuth2 password flow endpoint.
    
    Authenticate with username/password to receive JWT access token.
    Use this token in Authorization header: Bearer <token>
    """
    user = auth_provider.authenticate_user(form_data.username, form_data.password)
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    access_token_expires = timedelta(minutes=auth_provider.config["JWT_EXPIRE_MINUTES"])
    access_token = auth_provider.create_access_token(
        user=user, 
        expires_delta=access_token_expires
    )
    
    return Token(
        access_token=access_token,
        token_type="bearer",
        expires_in=auth_provider.config["JWT_EXPIRE_MINUTES"] * 60
    )

# User info endpoint
@router.get("/users/me", response_model=UserResponse)
async def read_users_me(current_user: User = Depends(require_authentication)):
    """
    Get current authenticated user information.
    
    Returns user details, roles, and permissions.
    Works with both JWT tokens and API keys.
    """
    return UserResponse(
        username=current_user.username,
        email=current_user.email or "",
        full_name=current_user.full_name or "",
        roles=current_user.roles,
        permissions=current_user.permissions,
        disabled=current_user.disabled
    )

# Health check endpoint
@router.get("/health", response_model=HealthResponse)
async def auth_health():
    """
    Authentication service health check.
    
    Public endpoint to verify auth service is running.
    """
    from datetime import datetime
    
    return HealthResponse(
        status="healthy",
        authentication="available",
        timestamp=datetime.utcnow().isoformat()
    )

# Protected demo endpoint
@router.get("/protected")
async def protected_demo(current_user: User = Depends(require_authentication)):
    """
    Demo protected endpoint.
    
    Requires valid authentication (JWT token or API key).
    Shows user context and available permissions.
    """
    auth_method = "API Key" if current_user.username.startswith("apikey:") else "JWT"
    
    return {
        "message": f"Hello {current_user.username}! This is a protected endpoint.",
        "user": {
            "username": current_user.username,
            "roles": [role.value for role in current_user.roles],
            "permissions": [perm.value for perm in current_user.permissions]
        },
        "auth_method": auth_method
    }

# Admin endpoints
@router.get("/admin/users")
async def list_users(current_user: User = Depends(require_role(Role.ADMIN))):
    """
    List all users (admin only).
    
    Requires admin role.
    """
    users = []
    for username, user_data in auth_provider.users_db.items():
        users.append({
            "username": user_data["username"],
            "email": user_data["email"],
            "full_name": user_data["full_name"],
            "roles": [role.value for role in user_data["roles"]],
            "disabled": user_data["disabled"]
        })
    
    return {"users": users}

@router.get("/admin/api-keys")
async def list_api_keys(current_user: User = Depends(require_permission(Permission.MANAGE_KEYS))):
    """
    List all API keys (admin/key manager only).
    
    Requires MANAGE_KEYS permission.
    """
    keys = []
    for key_value, key_data in auth_provider.api_keys_db.items():
        keys.append({
            "key_id": key_value[-8:] + "...",  # Show last 8 chars only
            "name": key_data["name"],
            "user": key_data["user"],
            "roles": [role.value for role in key_data["roles"]],
            "active": key_data["active"]
        })
    
    return {"api_keys": keys}

# Developer endpoints
@router.get("/developer/permissions")
async def check_permissions(current_user: User = Depends(require_role(Role.DEVELOPER))):
    """
    Check current user permissions (developer+ only).
    
    Useful for debugging permission issues.
    """
    return {
        "username": current_user.username,
        "roles": [role.value for role in current_user.roles],
        "permissions": [perm.value for perm in current_user.permissions],
        "can_create_agent": Permission.CREATE_AGENT in current_user.permissions,
        "can_view_metrics": Permission.VIEW_METRICS in current_user.permissions,
        "can_manage_users": Permission.MANAGE_USERS in current_user.permissions
    }

# Agent management endpoints (examples)
@router.post("/agents")
async def create_agent(current_user: User = Depends(require_permission(Permission.CREATE_AGENT))):
    """
    Create new agent (developer+ only).
    
    Placeholder endpoint demonstrating permission-based access.
    """
    return {
        "message": "Agent creation endpoint",
        "created_by": current_user.username,
        "note": "This is a placeholder - implement actual agent creation logic"
    }

@router.get("/agents")
async def list_agents(current_user: User = Depends(require_permission(Permission.READ_AGENT))):
    """
    List agents (all authenticated users).
    
    Viewers can read agents, developers can create/modify.
    """
    return {
        "message": "Agent listing endpoint",
        "user": current_user.username,
        "permissions": [perm.value for perm in current_user.permissions],
        "note": "This is a placeholder - implement actual agent listing logic"
    }

# Task management endpoints (examples)
@router.post("/tasks")
async def submit_task(current_user: User = Depends(require_permission(Permission.SUBMIT_TASK))):
    """
    Submit task to agent (all authenticated users).
    
    Basic permission check for task submission.
    """
    return {
        "message": "Task submission endpoint",
        "submitted_by": current_user.username,
        "note": "This is a placeholder - implement actual task submission logic"
    }

@router.get("/tasks/{task_id}")
async def get_task(
    task_id: str,
    current_user: User = Depends(require_permission(Permission.VIEW_TASK))
):
    """
    Get task details (all authenticated users).
    
    Basic permission check for task viewing.
    """
    return {
        "task_id": task_id,
        "message": "Task details endpoint",
        "requested_by": current_user.username,
        "note": "This is a placeholder - implement actual task retrieval logic"
    }

# ============================================================================
# FILE: api/wrapper.py
# ============================================================================

# api/wrapper.py
"""
Security wrapper for A2A applications.
Provides enterprise-grade authentication around existing A2A servers.
"""
import logging
import os
from typing import Optional, List
from fastapi import FastAPI
from starlette.applications import Starlette
from starlette.middleware.cors import CORSMiddleware
from config.agent_config import load_env_config, EnvironmentConfig

from api.routes import router as auth_router
from api.middleware import A2AAuthContextMiddleware

logger = logging.getLogger(__name__)


class A2ASecurityWrapper:
    """
    Enterprise security wrapper for A2A applications.
    Wraps existing A2A ASGI apps with FastAPI authentication while
    preserving all original A2A functionality and endpoints.
    Includes JWT principal injection into A2A RequestContext.
    """
    
    def __init__(
        self,
        a2a_asgi_app,
        config: Optional[EnvironmentConfig] = None,
        title: Optional[str] = None,
        version: Optional[str] = None,
        enable_cors: bool = True,
        cors_origins: Optional[List[str]] = None
    ):
        # Load configuration if not provided
        self.config = config or load_env_config()
        
        # Use config values with fallbacks to parameters
        self.title = title or self.config.get('AGENT_NAME', 'SAOP Agent')
        self.version = version or self.config.get('AGENT_VERSION', '1.0.0')
        self.a2a_app = a2a_asgi_app
        
        # Parse CORS origins from config if not provided
        if cors_origins is None:
            cors_env = os.getenv("CORS_ORIGINS", "")
            cors_origins = [origin.strip() for origin in cors_env.split(",") if origin.strip()]
        
        self.fastapi_app = self._create_secured_app(enable_cors, cors_origins)
        logger.info(f"Security wrapper initialized for {self.title} v{self.version}")

    def _create_secured_app(self, enable_cors: bool, cors_origins: Optional[List[str]]) -> FastAPI:
        """Create FastAPI wrapper with authentication and security middleware"""
        
        app = FastAPI(
            title=self.title,
            version=self.version,
            description=f"Enterprise SAOP agent with OAuth2 + API Key authentication",
            docs_url="/docs",
            redoc_url="/redoc",
            openapi_url="/openapi.json"
        )

        # Add CORS middleware if enabled
        if enable_cors:
            # Use configured origins or fallback to defaults
            allowed_origins = cors_origins or [
                "http://localhost:3000",  # React dev
                "http://localhost:8080",  # Vue dev  
                "http://localhost:5173",  # Vite dev
                "https://yourdomain.com"  # Production fallback
            ]
            
            app.add_middleware(
                CORSMiddleware,
                allow_origins=allowed_origins,
                allow_credentials=True,
                allow_methods=["GET", "POST", "PUT", "DELETE", "OPTIONS"],
                allow_headers=["*"],
            )
            logger.info(f"CORS enabled for origins: {allowed_origins}")

        # Add A2A authentication context middleware
        app.add_middleware(A2AAuthContextMiddleware)
        logger.info("A2A authentication context injection enabled")

        # Add authentication routes with configured endpoint
        # Extract base prefix (e.g., "auth" from "auth/token")
        token_endpoint = self.config.get('TOKEN_ENDPOINT', 'auth/token')
        if '/' in token_endpoint:
            auth_prefix = f"/{token_endpoint.split('/')[0]}"
        else:
            auth_prefix = f"/{token_endpoint.lstrip('/')}"
        
        app.include_router(auth_router, prefix=auth_prefix, tags=["authentication"])

        # Health check endpoint at root level
        @app.get("/health")
        async def health_check():
            """Service health check endpoint"""
            return {
                "status": "healthy",
                "service": self.title,
                "version": self.version,
                "authentication": "enabled",
                "a2a_auth_injection": "enabled",
                "agent_name": self.config.get('AGENT_NAME'),
                "model_provider": self.config.get('MODEL_PROVIDER'),
                "a2a_port": self.config.get('A2A_PORT'),
                "mcp_enabled": bool(self.config.get('MCP_BASE_URL')),
                "config_loaded": True
            }

        # A2A info endpoint
        @app.get("/.well-known/agent-card.json")
        async def agent_card():
            """A2A agent card endpoint"""
            return {
                "name": self.title,
                "version": self.version,
                "description": f"Enterprise SAOP agent with security wrapper",
                "capabilities": [
                    "authentication",
                    "authorization", 
                    "a2a_auth_context",
                    "mcp_integration",
                    "observability"
                ],
                "endpoints": {
                    "health": "/health",
                    "auth": auth_prefix,
                    "docs": "/docs",
                    "a2a_host": self.config.get('A2A_HOST', '0.0.0.0'),
                    "a2a_port": self.config.get('A2A_PORT', 9999)
                },
                "security": {
                    "jwt_issuer": self.config.get('JWT_ISSUER'),
                    "jwt_audience": self.config.get('JWT_AUDIENCE'),
                    "api_key_header": self.config.get('API_KEY_HEADER'),
                    "a2a_auth_required": True,
                    "principal_injection": "enabled"
                }
            }

        # Mount the A2A app at root to preserve all existing endpoints
        # This should be last to avoid conflicts with FastAPI routes
        app.mount("/", self.a2a_app)
        
        logger.info("FastAPI security wrapper configured successfully")
        logger.info(f"Authentication endpoint: {auth_prefix}")
        logger.info(f"A2A authentication context injection: enabled")
        logger.info(f"A2A host: {self.config.get('A2A_HOST')}:{self.config.get('A2A_PORT')}")
        logger.info(f"MCP endpoint: {self.config.get('MCP_BASE_URL')}")
        
        return app

    def get_asgi_app(self):
        """Get the secured ASGI application"""
        return self.fastapi_app

    def get_config(self) -> EnvironmentConfig:
        """Get the loaded configuration"""
        return self.config


def wrap_a2a_with_security(
    a2a_asgi_app,
    config: Optional[EnvironmentConfig] = None,
    title: Optional[str] = None,
    version: Optional[str] = None,
    enable_cors: bool = True,
    cors_origins: Optional[List[str]] = None
) -> FastAPI:
    """
    Convenience function to wrap A2A ASGI app with enterprise security.
    
    Args:
        a2a_asgi_app: The A2A ASGI application to secure
        config: Environment configuration object (will load from env if None)
        title: Service title for API documentation (uses AGENT_NAME from config if None)
        version: Service version (uses AGENT_VERSION from config if None)
        enable_cors: Whether to enable CORS middleware
        cors_origins: List of allowed CORS origins (uses CORS_ORIGINS from config if None)
        
    Returns:
        Secured FastAPI ASGI application with JWT principal injection
    """
    wrapper = A2ASecurityWrapper(
        a2a_asgi_app=a2a_asgi_app,
        config=config,
        title=title,
        version=version,
        enable_cors=enable_cors,
        cors_origins=cors_origins
    )
    return wrapper.get_asgi_app()


# Example usage for testing
if __name__ == "__main__":
    # Load configuration
    config = load_env_config()
    
    # Create a simple ASGI app for testing
    from starlette.applications import Starlette
    from starlette.responses import JSONResponse
    from starlette.routing import Route
    
    async def hello(request):
        # Check if authentication context is available
        user_principal = getattr(request.state, 'user_principal', None)
        return JSONResponse({
            "message": "Hello from A2A app!",
            "authenticated": user_principal is not None,
            "user": user_principal
        })
    
    test_a2a_app = Starlette(routes=[
        Route("/test", hello),
    ])
    
    # Wrap with security
    secured_app = wrap_a2a_with_security(test_a2a_app, config=config)
    
    print(f"Secured app created for {config['AGENT_NAME']} v{config['AGENT_VERSION']}")
    print(f"Available at: {config['A2A_HOST']}:{config['A2A_PORT']}")
    print(f"Health check: /health")
    print(f"Auth endpoint: /{config['TOKEN_ENDPOINT']}")
    print(f"API docs: /docs")
    print(f"Features: Authentication + A2A Context Injection")

# ============================================================================
# FILE: app.py
# ============================================================================

#app.py
import asyncio
from telemetry._telemetry import init_tracing 
from agent2agent.a2a_server import main

init_tracing()

if __name__ == "__main__":
    asyncio.run(main())
    

# ============================================================================
# FILE: langgraph/langgraph_executor.py
# ============================================================================

# langgraph/langgraph_executor.py (fixed with interactive CLI)
import asyncio
import uuid
from a2a.server.agent_execution import AgentExecutor
from a2a.server.agent_execution.context import RequestContext
from a2a.server.events.event_queue import EventQueue
from langgraph.agent_factory import AgentFactory
from agent2agent.a2a_tasks import A2ATask
from agent2agent.a2a_utils import create_cancellation_event

class LangGraphA2AExecutor(AgentExecutor):
    def __init__(self, role_name: str = "math_specialist"):
        self.role_name = role_name
        self.factory = AgentFactory()
        self.agent = None
        self._initialization_error = None
        self._degraded_mode = False

    def suggest_similar_role(self, invalid_role: str, available_roles: list[str]) -> str:
        """Find the most similar role using fuzzy matching"""
        from difflib import get_close_matches
        matches = get_close_matches(invalid_role, available_roles, n=1, cutoff=0.6)
        return matches[0] if matches else None
    
    def prompt_user_for_action(self, invalid_role: str, available_roles: list[str], suggestion: str = None) -> str:
        """Prompt user for action when role is not found"""
        print(f"\nRole '{invalid_role}' not found.")
        
        if suggestion:
            print(f"Did you mean '{suggestion}'?")
        
        print("\nAvailable roles:")
        for i, role in enumerate(available_roles, 1):
            print(f"  {i}. {role}")
        
        print(f"\nOptions:")
        print(f"  y - Use default role ('general_support')")
        print(f"  n - Stop server and fix configuration")
        print(f"  d - Run in degraded mode (no agent)")
        if suggestion:
            print(f"  s - Use suggested role ('{suggestion}')")
        
        while True:
            try:
                choice = input("\nChoose [y/n/d" + ("/s" if suggestion else "") + "]: ").strip().lower()
                
                if choice == 'y':
                    return 'general_support'
                elif choice == 'n':
                    print("Stopping server. Please update your configuration.")
                    exit(1)
                elif choice == 'd':
                    return None  # Degraded mode
                elif choice == 's' and suggestion:
                    return suggestion
                else:
                    valid_options = "y/n/d" + ("/s" if suggestion else "")
                    print(f"Invalid choice. Please enter {valid_options}")
                    
            except KeyboardInterrupt:
                print("\nStopping server.")
                exit(1)

    async def initialize(self):
        print(f"Initializing LangGraphA2AExecutor for role: {self.role_name}")
        
        try:
            # Create role-based agent using the factory
            self.agent = await self.factory.create_agent(self.role_name)
            
            if self.agent is None:
                error_msg = f"Agent factory returned None for role '{self.role_name}'"
                self._initialization_error = error_msg
                print(f"Failed to initialize executor for role '{self.role_name}': {error_msg}")
                self._degraded_mode = True
                return False
            
            self._tools = self.agent._tools
            tool_names = [tool.name for tool in self._tools]
            
            # Enhanced logging with role info
            role_info = self.agent.get_role_info()
            print(f"Executor '{self.role_name}' initialized successfully with {len(self._tools)} tools: {tool_names}")
            print(f"Role: {role_info['system_prompt']}")
            
            if self.agent.requires_human_review():
                print("This role requires human review for certain actions")
            
            return True
            
        except ValueError as e:
            # Handle invalid role names with interactive prompt
            if "not found" in str(e).lower():
                # Extract available roles from error message
                available_roles = []
                if "Available roles:" in str(e):
                    try:
                        available_roles_str = str(e).split("Available roles:")[1].strip()
                        import ast
                        available_roles = ast.literal_eval(available_roles_str)
                    except:
                        # Fallback: get from factory if possible
                        try:
                            available_roles = self.factory.list_roles()
                        except:
                            available_roles = ["general_support", "math_specialist", "research_assistant"]
                
                # Get fuzzy match suggestion
                suggestion = self.suggest_similar_role(self.role_name, available_roles)
                
                # Prompt user for action
                chosen_role = self.prompt_user_for_action(self.role_name, available_roles, suggestion)
                
                if chosen_role is None:
                    # Degraded mode
                    self._initialization_error = f"Running in degraded mode - role '{self.role_name}' not found"
                    self._degraded_mode = True
                    print(f"Running in degraded mode: {self._initialization_error}")
                    return False
                else:
                    # Try with chosen role
                    print(f"Using role: {chosen_role}")
                    self.role_name = chosen_role
                    return await self.initialize()  # Recursive call with new role
            else:
                # Other ValueError
                self._initialization_error = str(e)
                self._degraded_mode = True
                print(f"Executor role '{self.role_name}' validation failed: {str(e)}")
                print(f"Executor '{self.role_name}' running in degraded mode: {str(e)}")
                return False
            
        except Exception as e:
            # Handle any other initialization errors
            self._initialization_error = f"Failed to initialize agent: {str(e)}"
            self._degraded_mode = True
            print(f"Executor '{self.role_name}' runtime error: {str(e)}")
            print(f"Executor '{self.role_name}' running in degraded mode: {self._initialization_error}")
            return False

    def is_initialized(self) -> bool:
        """Check if the executor was successfully initialized"""
        return self.agent is not None and self._initialization_error is None

    def is_degraded(self) -> bool:
        """Check if the executor is running in degraded mode"""
        return self._degraded_mode

    def get_initialization_error(self) -> str:
        """Get the initialization error message if any"""
        return self._initialization_error

    async def execute(self, context: RequestContext, event_queue: EventQueue) -> None:
        if not self.is_initialized():
            error_msg = f"Agent not available: {self._initialization_error}"
            print(f"Execution blocked for '{self.role_name}': {self._initialization_error}")
            
            # Create proper error event using your existing A2A types
            from a2a.types import Message, TextPart, TaskStatusUpdateEvent, TaskStatus, TaskState, Role
            import uuid
            
            error_event = TaskStatusUpdateEvent(
                contextId=context.context_id,
                state=TaskState.failed,
                status=TaskStatus(
                    state=TaskState.failed,
                    message=Message(
                        messageId=str(uuid.uuid4()),
                        role=Role.agent,
                        parts=[TextPart(text=error_msg)]
                    )
                ),
                taskId=context.task_id,
                final=True,
            )
            await event_queue.enqueue_event(error_event)
            return
            
        task = A2ATask(self, context, event_queue)
        await task.run()

    async def cancel(self, context: RequestContext, event_queue: EventQueue) -> None:
        cancel_event = create_cancellation_event(context)
        await event_queue.enqueue_event(cancel_event)
        print(f"Executor '{self.role_name}' graceful recovery: Cancellation event published")

    async def run_agent(self, user_text: str):
        if not self.is_initialized():
            error_msg = f"Agent not initialized: {self._initialization_error}"
            print(f"Execution blocked for '{self.role_name}': {self._initialization_error}")
            raise RuntimeError(error_msg)
        return await self.agent.ainvoke(user_text)

# ============================================================================
# FILE: langgraph/agent_factory.py
# ============================================================================

# langgraph/agent_factory.py
"""
Agent Factory implementation that creates role-based agents.
Uses your existing AgentComponents and AgentTemplate as building blocks.
"""

import asyncio
from typing import Dict, List, Any, Optional
from langchain_core.tools import BaseTool
from langchain.chat_models import init_chat_model

from config.roles import get_roles
from _mcp.tools import TOOLS, BUNDLES, validate_bundle_names
from config.agent_config import load_env_config
from langgraph.langgraph_agent import AgentComponents, AgentTemplate
from langgraph.agent_factory_logger import AgentFactoryLogger


class AgentFactory:
    """
    Factory for creating role-based agents using existing components.
    Orchestrates AgentComponents and extends AgentTemplate with role filtering.
    """
    
    def __init__(self):
        self.logger = AgentFactoryLogger()
        self.env_config = load_env_config()
        self._all_tools_cache = None
        self._roles = get_roles()
        
        self.logger.log_factory_init(self._roles, BUNDLES, TOOLS)
        validate_bundle_names()
        self.logger.log_validation_success()
    
    async def _get_all_tools(self) -> List[BaseTool]:
        """Get all available tools using existing AgentComponents."""
        if self._all_tools_cache is not None:
            self.logger.log_tools_cache_hit()
            return self._all_tools_cache
            
        self.logger.log_tools_fetch_start()
        components = AgentComponents()
        self._all_tools_cache = await components.create_tools()
        self.logger.log_tools_fetch_complete(self._all_tools_cache)
        return self._all_tools_cache
    
    def _resolve_role_tools(self, role_config: Dict[str, Any]) -> List[str]:
        """
        Resolve which tools a role should have access to.
        Uses the same logic as your existing bundle system.
        """
        allowed_tools = set()
        role_name = role_config.get("name", "unknown")
        
        # Add direct tool references
        direct_tools = role_config.get("tools", [])
        bundles = role_config.get("tool_bundles", [])
        self.logger.log_role_tool_resolution(role_name, direct_tools, bundles)
        
        for tool_name in direct_tools:
            if tool_name in TOOLS:
                allowed_tools.add(tool_name)
            else:
                self.logger.log_missing_tool(tool_name, role_name)
        
        # Add tools from bundles
        for bundle_name in bundles:
            if bundle_name in BUNDLES:
                bundle_tools = BUNDLES[bundle_name]
                self.logger.log_bundle_expansion(bundle_name, bundle_tools)
                allowed_tools.update(bundle_tools)
            else:
                self.logger.log_missing_bundle(bundle_name, role_name)
                
        return list(allowed_tools)
    
    async def _filter_tools_for_role(self, role_name: str) -> List[BaseTool]:
        """
        Filter the full tool set to only include tools allowed for this role.
        """
        role_config = self._roles[role_name]
        allowed_tool_names = self._resolve_role_tools(role_config)
        self.logger.log_tool_filtering_start(role_name, allowed_tool_names)
        
        all_tools = await self._get_all_tools()
        
        # Filter tools by name - only include tools this role is allowed to use
        filtered_tools = []
        for tool in all_tools:
            if tool.name in allowed_tool_names:
                filtered_tools.append(tool)
                self.logger.log_tool_include(tool.name)
            else:
                self.logger.log_tool_exclude(tool.name)
        
        actual_tool_names = [tool.name for tool in filtered_tools]
        self.logger.log_tool_filtering_complete(role_name, actual_tool_names)
        
        if not filtered_tools:
            self.logger.log_no_tools_warning(role_name)
                
        return filtered_tools
    
    def _create_role_llm(self, role_config: Dict[str, Any]):
        """
        Create LLM with role-specific overrides if specified.
        Falls back to default config from AgentComponents.
        """
        role_name = role_config.get("name", "unknown")
        model_id = role_config.get("model_id")
        
        if model_id:
            self.logger.log_custom_llm_creation(role_name, model_id)
            # Parse provider:model format
            if ":" in model_id:
                provider, model_name = model_id.split(":", 1)
                return init_chat_model(
                    model=model_name,
                    model_provider=provider,
                    openai_api_key=self.env_config["MODEL_API_KEY"],
                )
            else:
                return init_chat_model(
                    model=model_id,
                    openai_api_key=self.env_config["MODEL_API_KEY"],
                    model_provider=self.env_config["MODEL_PROVIDER"],
                )
        else:
            self.logger.log_default_llm_creation(role_name)
            # Use default from AgentComponents
            components = AgentComponents()
            return components.create_llm()
    
    async def create_agent(self, role_name: str) -> "RoleBasedAgentTemplate":
        """
        Create an agent instance for the specified role.
        """
        self.logger.log_agent_creation_start(role_name)
        
        if role_name not in self._roles:
            available_roles = list(self._roles.keys())
            error_msg = self.logger.log_role_not_found(role_name, available_roles)
            raise ValueError(error_msg)
        
        role_config = self._roles[role_name]
        
        # Get role-specific components
        filtered_tools = await self._filter_tools_for_role(role_name)
        self.logger.log_role_details(role_config, len(filtered_tools))
        
        role_llm = self._create_role_llm(role_config)
        
        self.logger.log_agent_creation_complete(role_name, len(filtered_tools))
        
        return RoleBasedAgentTemplate(
            role_name=role_name,
            role_config=role_config,
            llm=role_llm,
            tools=filtered_tools,
            logger=self.logger
        )
    
    def list_roles(self) -> List[Dict[str, Any]]:
        """List all available roles with their metadata."""
        self.logger.log_list_roles_start()
        roles_info = []
        
        for name, config in self._roles.items():
            allowed_tools = self._resolve_role_tools(name, config)
            role_info = {
                "name": name,
                "system_prompt": config["system_prompt"],
                "tools": allowed_tools,
                "tool_bundles": config.get("tool_bundles", []),
                "tags": config["metadata"]["tags"],
                "cost_hint": config["metadata"]["cost_hint"],
                "human_review": config.get("human_review", False),
            }
            roles_info.append(role_info)
            self.logger.log_role_summary(name, len(allowed_tools), config["metadata"]["cost_hint"])
        
        self.logger.log_list_roles_complete(len(roles_info))
        return roles_info


class RoleBasedAgentTemplate(AgentTemplate):
    """
    Extended AgentTemplate that incorporates role-specific behavior.
    Preserves all existing AgentTemplate functionality while adding role context.
    """
    
    def __init__(self, role_name: str, role_config: Dict[str, Any], llm, tools: List[BaseTool], logger: AgentFactoryLogger):
        self.logger = logger
        self.logger.log_template_init_start(role_name)
        
        super().__init__()
        self.role_name = role_name
        self.role_config = role_config
        self._llm = llm
        self._tools = tools
        self._llm_chain = llm.bind_tools(tools)
        
        tool_names = [t.name for t in tools]
        self.logger.log_llm_binding(len(tools), tool_names)
        
        # Initialize graph with role-specific components
        self._init_graph()
        self.logger.log_template_init_complete(role_name)
    
    async def _initialize_components(self):
        """Override - components are already initialized in constructor."""
        if self._graph is not None:
            self.logger.log_components_already_initialized(self.role_name)
            return
        # Components already set up, just ensure graph is built
        if self._graph is None:
            self.logger.log_building_graph(self.role_name)
            self._init_graph()
    
    @property
    def system_prompt(self) -> str:
        """Get the system prompt for this role."""
        return self.role_config["system_prompt"]
    
    def get_role_info(self) -> Dict[str, Any]:
        """Get information about this agent's role."""
        return {
            "role_name": self.role_name,
            "system_prompt": self.system_prompt,
            "tools": [tool.name for tool in self._tools],
            "tool_count": len(self._tools),
            "metadata": self.role_config["metadata"]
        }
    
    def requires_human_review(self) -> bool:
        """Check if this role requires human review."""
        return self.role_config.get("human_review", False)

# ============================================================================
# FILE: agent2agent/a2a_tasks.py
# ============================================================================

# a2a_task.py

import asyncio
import uuid
from typing import Optional, List, cast
from a2a.server.agent_execution import AgentExecutor
from a2a.server.agent_execution.context import RequestContext
from a2a.server.events.event_queue import EventQueue
from a2a.types import (
    Message,
    TextPart,
    TaskStatusUpdateEvent,
    TaskStatus,
    TaskState,
    Role
)
from langchain_core.messages import HumanMessage, AIMessage, BaseMessage

class A2ATask:
    def __init__(self, executor: AgentExecutor, context: RequestContext, event_queue: EventQueue):
        self.executor = executor
        self.context = context
        self.event_queue = event_queue

    async def run(self):
        user_text = "".join(part.root.text for part in self.context.message.parts if part.root.kind == "text")

        try:
            working_event = TaskStatusUpdateEvent(
                contextId=self.context.context_id,
                state=TaskState.working,
                status=TaskStatus(
                    state=TaskState.working,
                    message=Message(
                        messageId=str(uuid.uuid4()),
                        role=Role.agent,
                        parts=[TextPart(text="Thinking...")]
                    )
                ),
                taskId=self.context.task_id,
                final=False,
            )
            await self.event_queue.enqueue_event(working_event)

            # Let the agent run and return its final, unparsed output.
            final_response = await self.executor._run_agent(user_text)
            
            # Get the final message from the graph's output
            final_agent_message = final_response.get("messages", [])[-1]

            # Convert to an A2A Message without any custom synthesis logic
            synthesized_text = ""
            if isinstance(final_agent_message, BaseMessage):
                synthesized_text = final_agent_message.content
            else:
                # Fallback for unexpected output types
                synthesized_text = str(final_agent_message)

            final_a2a_message = Message(
                messageId=str(uuid.uuid4()),
                role=Role.agent,
                parts=[TextPart(text=synthesized_text)]
            )
            
            success_event = TaskStatusUpdateEvent(
                contextId=self.context.context_id,
                state=TaskState.completed,
                status=TaskStatus(
                    state=TaskState.completed,
                    message=final_a2a_message,
                ),
                taskId=self.context.task_id,
                final=True,
            )
            await self.event_queue.enqueue_event(success_event)
            
        except Exception as e:
            print(f"An unexpected error occurred in executor: {e}")
            error_event = TaskStatusUpdateEvent(
                contextId=self.context.context_id,
                state=TaskState.failed,
                status=TaskStatus(
                    state=TaskState.failed,
                    message=Message(
                        messageId=str(uuid.uuid4()),
                        role=Role.agent,
                        parts=[TextPart(text=f"Execution error: {e}")]
                    )
                ),
                taskId=self.context.task_id,
                final=True,
            )
            await self.event_queue.enqueue_event(error_event)

# ============================================================================
# FILE: config/agent_config.py
# ============================================================================

import os
from typing import TypedDict, Optional, List, Dict, Any, Union
import datetime
from dotenv import load_dotenv

class ToolConfig(TypedDict):
    name: str
    description: str
    input_schema: Dict[str, Any]
    output_schema: Dict[str, Any]

class AgentYAMLConfig(TypedDict):
    id: str
    name: str
    description: str
    version: str
    role: str
    prompt_template: str
    resources: List[str]
    knowledge_base: Optional[str]
    graph: Dict
    created: datetime.datetime
    updated: datetime.datetime
    agents: List[str]
    tools: List[ToolConfig]

class EnvironmentConfig(TypedDict):
    # Agent Config
    AGENT_NAME=str
    AGENT_VERSION=str

    # AI Model Configuration
    MODEL_API_KEY: str
    MODEL_BASE_URL: str
    MODEL_NAME: str
    MODEL_TEMPERATURE: float
    MODEL_PROVIDER: str
    
    # A2A Configuration
    A2A_AGENT_CARD_PATH: str
    A2A_HOST: str
    A2A_PORT: int
    
    # MCP Configuration
    MCP_BASE_URL: str
    MCP_HOST: str
    MCP_PORT: int
    MCP_GITHUB_BASE_URL: str
    SAMPLE01_MCP_TOOL_API_KEY: Optional[str]
    SAMPLE02_MCP_TOOL_API_KEY: Optional[str]
    
    # JWT Authentication Configuration
    JWT_SECRET_KEY: str
    JWT_ALGORITHM: str
    JWT_EXPIRE_MINUTES: int
    JWT_ISSUER: str
    JWT_AUDIENCE: str
    API_KEY_HEADER: str
    USER_STORE_TYPE: str
    
    # Default Users (Development)
    DEFAULT_ADMIN_USERNAME: str
    DEFAULT_ADMIN_PASSWORD_HASH: str
    DEFAULT_ADMIN_EMAIL: str
    DEFAULT_DEV_USERNAME: str
    DEFAULT_DEV_PASSWORD_HASH: str
    DEFAULT_DEV_EMAIL: str
    DEFAULT_DEV_API_KEY: str
    
    # Observability Configuration
    OTEL_EXPORTER_OTLP_ENDPOINT: str
    OTEL_SERVICE_NAME: str
    OTEL_EXPORTER_OTLP_PROTOCOL: str
    OTEL_RESOURCE_ATTRIBUTES: str
    OTEL_TRACES_SAMPLER: str
    
    # Database & Caching
    REDIS_URL: Optional[str]
    DATABASE_URL: Optional[str]
    DB_USER: Optional[str]
    DB_PASSWORD: Optional[str]
    DB_HOST: Optional[str]
    DB_PORT: Optional[int]
    DB_NAME: Optional[str]
    
    # Auth & Secret Management
    AUTH_CLIENT_ID: Optional[str]
    AUTH_CLIENT_SECRET: Optional[str]
    HASHICORP_VAULT_ADDR: Optional[str]
    AWS_SECRETS_MANAGER_ARN: Optional[str]
    GITHUB_PAT: Optional[str]

    # FastAPI Security Configuration
    TOKEN_ENDPOINT: str
    DEFAULT_ADMIN_FULL_NAME: str
    DEFAULT_DEV_FULL_NAME: str

class SAOPAgentConfig(TypedDict):
    agent: AgentYAMLConfig
    environment: EnvironmentConfig

def load_env_config() -> EnvironmentConfig:
    # Ensure .env file is loaded before accessing variables
    load_dotenv()
    return EnvironmentConfig(
        #AI Agent Vars
        AGENT_NAME=os.environ.get("AGENT_NAME", "DefaultSAOPAgent"),
        AGENT_VERSION=os.environ.get("AGENT_VERSION", ""),

        # AI Model Vars
        MODEL_API_KEY=os.environ.get("MODEL_API_KEY", ""),
        MODEL_BASE_URL=os.environ.get("MODEL_BASE_URL", ""),
        MODEL_NAME=os.environ.get("MODEL_NAME", "0.0.0.0"),
        MODEL_TEMPERATURE=float(os.environ.get("MODEL_TEMPERATURE", 0.7)),
        MODEL_PROVIDER=os.environ.get("MODEL_PROVIDER", ""),
        
        # A2A Vars
        A2A_AGENT_CARD_PATH=os.environ.get("A2A_AGENT_CARD_PATH", ""),
        A2A_HOST=os.environ.get("A2A_HOST", ""),
        A2A_PORT=int(os.environ.get("A2A_PORT", 9999)),
        
        # MCP Vars
        MCP_BASE_URL=os.environ.get("MCP_BASE_URL", ""),
        MCP_HOST=os.environ.get("MCP_HOST", "127.0.0.1"),
        MCP_PORT=int(os.environ.get("MCP_PORT", "9000")),
        MCP_GITHUB_BASE_URL=os.environ.get("MCP_GITHUB_BASE_URL", ""),
        SAMPLE01_MCP_TOOL_API_KEY=os.getenv("SAMPLE01_MCP_TOOL_API_KEY"),
        SAMPLE02_MCP_TOOL_API_KEY=os.getenv("SAMPLE02_MCP_TOOL_API_KEY"),
        
        # JWT Auth Vars
        JWT_SECRET_KEY=os.environ.get("JWT_SECRET_KEY", "dev-secret-change-in-production"),
        JWT_ALGORITHM=os.environ.get("JWT_ALGORITHM", "HS256"),
        JWT_EXPIRE_MINUTES=int(os.environ.get("JWT_EXPIRE_MINUTES", "30")),
        JWT_ISSUER=os.environ.get("JWT_ISSUER", "langgraph.agent"),
        JWT_AUDIENCE=os.environ.get("JWT_AUDIENCE", "langgraph.users"),
        API_KEY_HEADER=os.environ.get("API_KEY_HEADER", "X-API-Key"),
        USER_STORE_TYPE=os.environ.get("USER_STORE_TYPE", "memory"),
        
        # Default Users
        DEFAULT_ADMIN_USERNAME=os.environ.get("DEFAULT_ADMIN_USERNAME", "admin"),
        DEFAULT_ADMIN_PASSWORD_HASH=os.environ.get("DEFAULT_ADMIN_PASSWORD_HASH", ""),
        DEFAULT_ADMIN_EMAIL=os.environ.get("DEFAULT_ADMIN_EMAIL", "admin@example.com"),
        DEFAULT_DEV_USERNAME=os.environ.get("DEFAULT_DEV_USERNAME", "dev"),
        DEFAULT_DEV_PASSWORD_HASH=os.environ.get("DEFAULT_DEV_PASSWORD_HASH", ""),
        DEFAULT_DEV_EMAIL=os.environ.get("DEFAULT_DEV_EMAIL", "dev@example.com"),
        DEFAULT_DEV_API_KEY=os.environ.get("DEFAULT_DEV_API_KEY", "dev-api-key-12345"),
        
        # OpenTel Vars
        OTEL_EXPORTER_OTLP_ENDPOINT=os.environ.get("OTEL_EXPORTER_OTLP_ENDPOINT", "http://localhost:4318"),
        OTEL_SERVICE_NAME=os.environ.get("OTEL_SERVICE_NAME", "langgraph.agent"),
        OTEL_EXPORTER_OTLP_PROTOCOL=os.environ.get("OTEL_EXPORTER_OTLP_PROTOCOL", "http/protobuf"),
        OTEL_RESOURCE_ATTRIBUTES=os.environ.get("OTEL_RESOURCE_ATTRIBUTES", "deployment.environment=local,service.version=0.0.1"),
        OTEL_TRACES_SAMPLER=os.environ.get("OTEL_TRACES_SAMPLER", "parentbased_always_on"),
        
        # DB & Cache Vars
        REDIS_URL=os.getenv("REDIS_URL"),
        DATABASE_URL=os.getenv("DATABASE_URL"),
        DB_USER=os.getenv("DB_USER"),
        DB_PASSWORD=os.getenv("DB_PASSWORD"),
        DB_HOST=os.getenv("DB_HOST"),
        DB_PORT=int(os.getenv("DB_PORT", "5432")) if os.getenv("DB_PORT") else None,
        DB_NAME=os.getenv("DB_NAME"),
        
        # Auth Vars
        AUTH_CLIENT_ID=os.getenv("AUTH_CLIENT_ID"),
        AUTH_CLIENT_SECRET=os.getenv("AUTH_CLIENT_SECRET"),
        HASHICORP_VAULT_ADDR=os.getenv("HASHICORP_VAULT_ADDR"),
        AWS_SECRETS_MANAGER_ARN=os.getenv("AWS_SECRETS_MANAGER_ARN"),
        GITHUB_PAT=os.getenv("GITHUB_PAT", ""),

        # FastAPI Security Vars
        TOKEN_ENDPOINT=os.environ.get("TOKEN_ENDPOINT", "auth/token"),
        DEFAULT_ADMIN_FULL_NAME=os.environ.get("DEFAULT_ADMIN_FULL_NAME", "Administrator"),
        DEFAULT_DEV_FULL_NAME=os.environ.get("DEFAULT_DEV_FULL_NAME", "Developer")
    )

if __name__ == "__main__":
    env_config = load_env_config()
    # You can now use the structured object
    print("Loaded Environment Configuration:")
    print(f"Model Name: {env_config['MODEL_NAME']}")
    print(f"MCP Base URL: {env_config['MCP_BASE_URL']}")
    print(f"A2A Port: {env_config['A2A_PORT']}")
    print(f"JWT Issuer: {env_config['JWT_ISSUER']}")
    print(f"Default Admin User: {env_config['DEFAULT_ADMIN_USERNAME']}")
    print(f"Database URL (Optional): {env_config.get('DATABASE_URL')}")

# ============================================================================
# FILE: api/auth.py
# ============================================================================

# api/auth.py
"""
Authentication provider for SAOP agent platform.
Handles JWT token validation and API key authentication.
"""
from datetime import datetime, timedelta
from typing import Optional, List, Set
from jose import JWTError, jwt
from passlib.context import CryptContext
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, APIKeyHeader
from pydantic import BaseModel
from enum import Enum

from config.agent_config import load_env_config

class Role(str, Enum):
    ADMIN = "admin"
    DEVELOPER = "developer" 
    VIEWER = "viewer"

class Permission(str, Enum):
    CREATE_AGENT = "agent:create"
    READ_AGENT = "agent:read"
    UPDATE_AGENT = "agent:update"
    DELETE_AGENT = "agent:delete"
    SUBMIT_TASK = "task:submit"
    VIEW_TASK = "task:view"
    VIEW_TRACES = "traces:view"
    VIEW_METRICS = "metrics:view"
    MANAGE_USERS = "admin:users"
    MANAGE_KEYS = "admin:keys"

# Role permissions mapping
ROLE_PERMISSIONS = {
    Role.VIEWER: {
        Permission.READ_AGENT,
        Permission.SUBMIT_TASK,
        Permission.VIEW_TASK,
        Permission.VIEW_TRACES
    },
    Role.DEVELOPER: {
        Permission.CREATE_AGENT,
        Permission.READ_AGENT,
        Permission.UPDATE_AGENT,
        Permission.SUBMIT_TASK,
        Permission.VIEW_TASK,
        Permission.VIEW_TRACES,
        Permission.VIEW_METRICS
    },
    Role.ADMIN: {
        Permission.CREATE_AGENT,
        Permission.READ_AGENT,
        Permission.UPDATE_AGENT,
        Permission.DELETE_AGENT,
        Permission.SUBMIT_TASK,
        Permission.VIEW_TASK,
        Permission.VIEW_TRACES,
        Permission.VIEW_METRICS,
        Permission.MANAGE_USERS,
        Permission.MANAGE_KEYS
    }
}

class Token(BaseModel):
    access_token: str
    token_type: str = "bearer"
    expires_in: Optional[int] = None

class User(BaseModel):
    username: str
    email: Optional[str] = None
    full_name: Optional[str] = None
    disabled: bool = False
    roles: List[Role] = []
    permissions: List[Permission] = []

class UserInDB(User):
    hashed_password: str

class AuthenticationProvider:
    """
    Centralized authentication provider for SAOP platform.
    Handles JWT validation, API key authentication, and user management.
    """
    
    def __init__(self):
        self.config = load_env_config()
        self.pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
        
        # Configure OAuth2 with proper token endpoint
        token_endpoint = self.config.get("TOKEN_ENDPOINT", "auth/token")
        if not token_endpoint.startswith("/"):
            token_endpoint = f"/{token_endpoint}"
        
        self.oauth2_scheme = OAuth2PasswordBearer(
            tokenUrl=token_endpoint.lstrip("/"),  # Remove leading slash for tokenUrl
            auto_error=False
        )
        
        self.api_key_header = APIKeyHeader(
            name=self.config["API_KEY_HEADER"],
            auto_error=False
        )
        self._initialize_users()
        self._initialize_api_keys()
    
    def _initialize_users(self):
        """Initialize user database from configuration"""
        self.users_db = {
            self.config["DEFAULT_ADMIN_USERNAME"]: {
                "username": self.config["DEFAULT_ADMIN_USERNAME"],
                "full_name": self.config.get("DEFAULT_ADMIN_FULL_NAME", "Administrator"),
                "email": self.config["DEFAULT_ADMIN_EMAIL"],
                "hashed_password": self.config["DEFAULT_ADMIN_PASSWORD_HASH"],
                "disabled": False,
                "roles": [Role.ADMIN]
            },
            self.config["DEFAULT_DEV_USERNAME"]: {
                "username": self.config["DEFAULT_DEV_USERNAME"],
                "full_name": self.config.get("DEFAULT_DEV_FULL_NAME", "Developer"),
                "email": self.config["DEFAULT_DEV_EMAIL"],
                "hashed_password": self.config["DEFAULT_DEV_PASSWORD_HASH"],
                "disabled": False,
                "roles": [Role.DEVELOPER]
            }
        }
    
    def _initialize_api_keys(self):
        """Initialize API key database from configuration"""
        self.api_keys_db = {
            self.config["DEFAULT_DEV_API_KEY"]: {
                "name": "Development API Key",
                "user": self.config["DEFAULT_DEV_USERNAME"],
                "roles": [Role.DEVELOPER],
                "active": True
            }
        }
    
    def get_user_permissions(self, roles: List[Role]) -> List[Permission]:
        """Get all permissions for given roles"""
        permissions = set()
        for role in roles:
            permissions.update(ROLE_PERMISSIONS.get(role, set()))
        return list(permissions)
    
    def verify_password(self, plain_password: str, hashed_password: str) -> bool:
        """Verify password against hash"""
        return self.pwd_context.verify(plain_password, hashed_password)
    
    def hash_password(self, password: str) -> str:
        """Generate password hash"""
        return self.pwd_context.hash(password)
    
    def get_user(self, username: str) -> Optional[UserInDB]:
        """Get user by username"""
        if username in self.users_db:
            user_data = self.users_db[username].copy()
            user_data["permissions"] = self.get_user_permissions(user_data["roles"])
            return UserInDB(**user_data)
        return None
    
    def authenticate_user(self, username: str, password: str) -> Optional[UserInDB]:
        """Authenticate user credentials"""
        user = self.get_user(username)
        if not user or user.disabled:
            return None
        
        if not self.verify_password(password, user.hashed_password):
            return None
        
        return user
    
    def create_access_token(self, user: UserInDB, expires_delta: Optional[timedelta] = None) -> str:
        """Create JWT access token for user"""
        if expires_delta:
            expire = datetime.utcnow() + expires_delta
        else:
            expire = datetime.utcnow() + timedelta(minutes=self.config["JWT_EXPIRE_MINUTES"])
        
        payload = {
            "sub": user.username,
            "exp": expire,
            "iat": datetime.utcnow(),
            "iss": self.config["JWT_ISSUER"],
            "aud": self.config["JWT_AUDIENCE"],
            "roles": [role.value for role in user.roles],
            "permissions": [perm.value for perm in user.permissions]
        }
        
        return jwt.encode(payload, self.config["JWT_SECRET_KEY"], algorithm=self.config["JWT_ALGORITHM"])
    
    def validate_token(self, token: str) -> Optional[User]:
        """Validate JWT token and return user"""
        try:
            payload = jwt.decode(
                token,
                self.config["JWT_SECRET_KEY"],
                algorithms=[self.config["JWT_ALGORITHM"]],
                audience=self.config["JWT_AUDIENCE"],
                issuer=self.config["JWT_ISSUER"]
            )
            
            username = payload.get("sub")
            if not username:
                return None
            
            roles = [Role(role) for role in payload.get("roles", [])]
            permissions = [Permission(perm) for perm in payload.get("permissions", [])]
            
            return User(
                username=username,
                roles=roles,
                permissions=permissions
            )
            
        except (JWTError, ValueError):
            return None
    
    def validate_api_key(self, api_key: str) -> Optional[User]:
        """Validate API key and return service user"""
        if api_key not in self.api_keys_db:
            return None
        
        key_data = self.api_keys_db[api_key]
        if not key_data["active"]:
            return None
        
        roles = key_data["roles"]
        permissions = self.get_user_permissions(roles)
        
        return User(
            username=f"apikey:{key_data['name']}",
            email=f"{key_data['user']}@service.local",
            full_name=f"API Key: {key_data['name']}",
            roles=roles,
            permissions=permissions
        )

# Global authentication provider instance
auth_provider = AuthenticationProvider()

# FastAPI dependency functions
async def get_current_user(
    token: Optional[str] = Depends(auth_provider.oauth2_scheme),
    api_key: Optional[str] = Depends(auth_provider.api_key_header)
) -> Optional[User]:
    """Get current authenticated user from token or API key"""
    if api_key:
        user = auth_provider.validate_api_key(api_key)
        if user:
            return user
    
    if token:
        user = auth_provider.validate_token(token)
        if user:
            return user
    
    return None

async def require_authentication(
    current_user: Optional[User] = Depends(get_current_user)
) -> User:
    """Require valid authentication"""
    if not current_user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Authentication required",
            headers={"WWW-Authenticate": "Bearer"}
        )
    
    if current_user.disabled:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Account disabled"
        )
    
    return current_user

def require_permission(permission: Permission):
    """Dependency factory for permission-based access control"""
    def permission_checker(current_user: User = Depends(require_authentication)) -> User:
        if permission not in current_user.permissions:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Permission denied: {permission.value}"
            )
        return current_user
    return permission_checker

def require_role(role: Role):
    """Dependency factory for role-based access control"""
    def role_checker(current_user: User = Depends(require_authentication)) -> User:
        if role not in current_user.roles:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Role required: {role.value}"
            )
        return current_user
    return role_checker

# ============================================================================
# FILE: telemetry/_telemetry.py
# ============================================================================

# telemetry.py
"""
Telemetry initializer for OpenTelemetry.
Call init_tracing() once at startup to enable traces.
"""

import os
from typing import Dict

# Core OpenTelemetry imports
from opentelemetry import trace
from opentelemetry.sdk.resources import Resource
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor
from opentelemetry.exporter.otlp.proto.http.trace_exporter import OTLPSpanExporter

from dotenv import load_dotenv
load_dotenv() 

def _parse_headers(raw: str | None) -> Dict[str, str]:
    """
    Helper: turns a string like:
        "authorization=Bearer mytoken,env=prod"
    into:
        {"authorization": "Bearer mytoken", "env": "prod"}
    Used for OTEL_EXPORTER_OTLP_HEADERS if backend needs extra headers.
    """
    if not raw:
        return {}
    pairs = [p.strip() for p in raw.split(",") if p.strip()]
    out: Dict[str, str] = {}
    for p in pairs:
        if "=" in p:
            k, v = p.split("=", 1)
            out[k.strip()] = v.strip()
    return out


def init_tracing() -> None:
    """
    Initialize OpenTelemetry tracing with OTLP exporter.
    Reads config from environment variables:
        OTEL_SERVICE_NAME          - Name of this service (e.g., "agent-factory")
        OTEL_EXPORTER_OTLP_ENDPOINT - Where to send traces (default: http://localhost:4318)
        OTEL_EXPORTER_OTLP_HEADERS  - Optional headers (comma-separated key=value)
    """

    # --- Define "who is sending telemetry" (the Resource)
    service_name = os.getenv("OTEL_SERVICE_NAME")
    resource = Resource.create({
        "service.name": service_name,
    })

    # --- Create and register the global tracer provider
    provider = TracerProvider(resource=resource)
    trace.set_tracer_provider(provider)

    # --- Configure the OTLP exporter (default = local collector on port 4318)
    endpoint = os.getenv("OTEL_EXPORTER_OTLP_ENDPOINT").rstrip("/")
    headers = _parse_headers(os.getenv("OTEL_EXPORTER_OTLP_HEADERS"))
    exporter = OTLPSpanExporter(
        endpoint=f"{endpoint}/v1/traces",
        headers=headers or None,
        timeout=10,
    )

    # --- Add a BatchSpanProcessor (efficiently sends spans in the background)
    processor = BatchSpanProcessor(exporter)
    provider.add_span_processor(processor)

    # --- Create a test span so you can confirm it's working
    tracer = trace.get_tracer("startup")
    with tracer.start_as_current_span("otlp_init_ok"):
        # Span starts here and ends when we leave this block
        pass

# ============================================================================
# FILE: telemetry/langgraph_trace_utils.py
# ============================================================================



import os
import hashlib
import inspect
import time
from functools import wraps
from typing import Optional, Any, Dict
from opentelemetry import trace
# from opentelemetry.trace import Span
# from opentelemetry.sdk.trace import TracerProvider
# from opentelemetry.sdk.trace.export import BatchSpanProcessor
# from opentelemetry.exporter.otlp.proto.grpc.trace_exporter import OTLPSpanExporter
# from opentelemetry.sdk.resources import Resource
from langchain_core.messages import AIMessage


def create_agent_id(name: str, role: Optional[str] = None) -> str:
    """Create a unique agent ID based on name and role."""
    import hashlib
    agent_str = f"{name}:{role}" if role else name
    return hashlib.sha256(agent_str.encode()).hexdigest()


def extract_llm_metadata(result: Any) -> Dict[str, Any]:
    """
    Extract LLM metadata from the result, including model info, tokens, and other metrics.
    """
    metadata = {}
    
    # Handle dictionary results with 'messages' key
    if isinstance(result, dict) and 'messages' in result:
        messages = result['messages']
        if isinstance(messages, list):
            for msg in messages:
                if isinstance(msg, AIMessage):
                    # Extract model information
                    if hasattr(msg, 'response_metadata'):
                        resp_meta = msg.response_metadata
                        
                        # Model information
                        if 'model_name' in resp_meta:
                            metadata['model_name'] = resp_meta['model_name']
                        
                        # Token usage information
                        if 'token_usage' in resp_meta:
                            token_usage = resp_meta['token_usage']
                            metadata['input_tokens'] = token_usage.get('prompt_tokens', 0)
                            metadata['output_tokens'] = token_usage.get('completion_tokens', 0)
                            metadata['total_tokens'] = token_usage.get('total_tokens', 0)
                            
                            # Detailed token information if available
                            if 'completion_tokens_details' in token_usage:
                                details = token_usage['completion_tokens_details']
                                metadata['reasoning_tokens'] = details.get('reasoning_tokens', 0)
                                metadata['audio_tokens'] = details.get('audio_tokens', 0)
                            
                            if 'prompt_tokens_details' in token_usage:
                                details = token_usage['prompt_tokens_details']
                                metadata['cached_tokens'] = details.get('cached_tokens', 0)
                        
                        # System information
                        if 'system_fingerprint' in resp_meta:
                            metadata['system_fingerprint'] = resp_meta['system_fingerprint']
                        
                        if 'service_tier' in resp_meta:
                            metadata['service_tier'] = resp_meta['service_tier']
                        
                        if 'finish_reason' in resp_meta:
                            metadata['finish_reason'] = resp_meta['finish_reason']
                    
                    # Also check usage_metadata if available
                    if hasattr(msg, 'usage_metadata'):
                        usage_meta = msg.usage_metadata
                        if usage_meta:
                            # Update token counts if not already set
                            if 'input_tokens' not in metadata and hasattr(usage_meta, 'input_tokens'):
                                metadata['input_tokens'] = usage_meta.input_tokens
                            if 'output_tokens' not in metadata and hasattr(usage_meta, 'output_tokens'):
                                metadata['output_tokens'] = usage_meta.output_tokens
                            if 'total_tokens' not in metadata and hasattr(usage_meta, 'total_tokens'):
                                metadata['total_tokens'] = usage_meta.total_tokens
                    
                    # Extract content length as a fallback metric
                    if hasattr(msg, 'content') and msg.content:
                        metadata['response_length'] = len(str(msg.content))
                    
                    break  # Process only the first AIMessage
    
    return metadata


def enrich_span_with_llm_metadata(
    span: trace.Span,
    result: Any,
    start_time: float,
    end_time: float
):
    """
    Enrich the span with LLM-specific metadata including model, tokens, and latency.
    """
    # Calculate latency
    latency_ms = (end_time - start_time) * 1000
    span.set_attribute("llm.latency_ms", latency_ms)
    
    # Extract and set LLM metadata
    metadata = extract_llm_metadata(result)
    
    # Set model attributes
    if 'model_name' in metadata:
        span.set_attribute("llm.model", metadata['model_name'])
    
    # Set token usage attributes
    if 'input_tokens' in metadata:
        span.set_attribute("llm.usage.input_tokens", metadata['input_tokens'])
    if 'output_tokens' in metadata:
        span.set_attribute("llm.usage.output_tokens", metadata['output_tokens'])
    if 'total_tokens' in metadata:
        span.set_attribute("llm.usage.total_tokens", metadata['total_tokens'])
    
    # Set detailed token attributes if available
    if 'reasoning_tokens' in metadata:
        span.set_attribute("llm.usage.reasoning_tokens", metadata['reasoning_tokens'])
    if 'cached_tokens' in metadata:
        span.set_attribute("llm.usage.cached_tokens", metadata['cached_tokens'])
    if 'audio_tokens' in metadata:
        span.set_attribute("llm.usage.audio_tokens", metadata['audio_tokens'])
    
    # Set system attributes
    if 'system_fingerprint' in metadata:
        span.set_attribute("llm.system_fingerprint", metadata['system_fingerprint'])
    if 'service_tier' in metadata:
        span.set_attribute("llm.service_tier", metadata['service_tier'])
    if 'finish_reason' in metadata:
        span.set_attribute("llm.finish_reason", metadata['finish_reason'])
    
    # Set response size
    if 'response_length' in metadata:
        span.set_attribute("llm.response_length", metadata['response_length'])
    
    # Calculate tokens per second if we have the data
    if 'total_tokens' in metadata and latency_ms > 0:
        tokens_per_second = (metadata['total_tokens'] / latency_ms) * 1000
        span.set_attribute("llm.tokens_per_second", tokens_per_second)


def track_agent(
    node_name: str,
    is_agent: bool = False,
    agent_role: Optional[str] = None):

    """
    A decorator to create an OpenTelemetry span for a LangGraph node.
    Captures model information, token usage, and latency for LLM nodes.
    """
    agent_id = (
        None if not is_agent else create_agent_id(name=node_name, role=agent_role)
    )
    
    def decorator(func):
        if inspect.iscoroutinefunction(func):
            @wraps(func)
            async def awrapper(*args, **kwargs):
                tracer = trace.get_tracer(__name__)
                start_time = time.time()
                
                with tracer.start_as_current_span(node_name) as span:
                    span.set_attribute("langgraph.node.name", node_name)
                    
                    # Set agent attributes if applicable
                    if is_agent and agent_id:
                        span.set_attribute("codon.is_agent", is_agent)
                        span.set_attribute("codon.agent.id", agent_id)
                        if agent_role:
                            span.set_attribute("codon.agent.role", agent_role)
                    
                    try:
                        result = await func(*args, **kwargs)
                        end_time = time.time()
                        
                        # Set output (truncated for large outputs)
                        output_str = str(result)
                        if len(output_str) > 1000:
                            output_str = output_str[:1000] + "... [truncated]"
                        span.set_attribute("langgraph.node.outputs", output_str)
                        
                        # Enrich with LLM metadata if this is an agent node
                        if is_agent:
                            enrich_span_with_llm_metadata(span, result, start_time, end_time)
                        else:
                            # Still set latency for non-agent nodes
                            latency_ms = (end_time - start_time) * 1000
                            span.set_attribute("node.latency_ms", latency_ms)
                        
                        # Set status to OK
                        span.set_status(trace.Status(trace.StatusCode.OK))
                        
                    except Exception as e:
                        # Record exception and set error status
                        span.record_exception(e)
                        span.set_status(
                            trace.Status(trace.StatusCode.ERROR, str(e))
                        )
                        raise
                    
                    return result
            
            return awrapper
        else:
            @wraps(func)
            def wrapper(*args, **kwargs):
                tracer = trace.get_tracer(__name__)
                start_time = time.time()
                
                with tracer.start_as_current_span(node_name) as span:
                    span.set_attribute("langgraph.node.name", node_name)
                    
                    # Set agent attributes if applicable
                    if is_agent and agent_id:
                        span.set_attribute("codon.is_agent", is_agent)
                        span.set_attribute("codon.agent.id", agent_id)
                        if agent_role:
                            span.set_attribute("codon.agent.role", agent_role)
                    
                    try:
                        result = func(*args, **kwargs)
                        end_time = time.time()
                        
                        # Set output (truncated for large outputs)
                        output_str = str(result)
                        if len(output_str) > 1000:
                            output_str = output_str[:1000] + "... [truncated]"
                        span.set_attribute("langgraph.node.outputs", output_str)
                        
                        # Enrich with LLM metadata if this is an agent node
                        if is_agent:
                            enrich_span_with_llm_metadata(span, result, start_time, end_time)
                        else:
                            # Still set latency for non-agent nodes
                            latency_ms = (end_time - start_time) * 1000
                            span.set_attribute("node.latency_ms", latency_ms)
                        
                        # Set status to OK
                        span.set_status(trace.Status(trace.StatusCode.OK))
                        
                    except Exception as e:
                        # Record exception and set error status
                        span.record_exception(e)
                        span.set_status(
                            trace.Status(trace.StatusCode.ERROR, str(e))
                        )
                        raise
                    
                    return result
            
            return wrapper
    
    return decorator

# ============================================================================
# COMPILATION SUMMARY
# ============================================================================
# Total files processed: 10
# Generated on: 2025-09-10 11:26:22
# Working directory: /Users/dj/saop_cli/saop/templates/base_agent
